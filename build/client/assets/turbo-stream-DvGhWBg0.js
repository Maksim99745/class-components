var b=Object.defineProperty;var O=(r,e,a)=>e in r?b(r,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):r[e]=a;var d=(r,e,a)=>O(r,typeof e!="symbol"?e+"":e,a);var P=-1,j=-2,_=-3,D=-4,Y=-5,R=-6,L=-7,A="B",U="D",m="E",B="M",M="N",g="P",V="R",k="S",G="Y",J="U",F="Z",S=class{constructor(){d(this,"promise");d(this,"resolve");d(this,"reject");this.promise=new Promise((r,e)=>{this.resolve=r,this.reject=e})}};function q(){const r=new TextDecoder;let e="";return new TransformStream({transform(a,s){const l=r.decode(a,{stream:!0}),t=(e+l).split(`
`);e=t.pop()||"";for(const o of t)s.enqueue(o)},flush(a){e&&a.enqueue(e)}})}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");var y=typeof window<"u"?window:typeof globalThis<"u"?globalThis:void 0;function p(r){const{hydrated:e,values:a}=this;if(typeof r=="number")return i.call(this,r);if(!Array.isArray(r)||!r.length)throw new SyntaxError;const s=a.length;return a.push(...r),e.length=a.length,i.call(this,s)}function i(r){const{hydrated:e,values:a,deferred:s,plugins:l}=this;switch(r){case L:return;case Y:return null;case j:return NaN;case R:return 1/0;case _:return-1/0;case D:return-0}if(e[r])return e[r];const t=a[r];if(!t||typeof t!="object")return e[r]=t;if(Array.isArray(t))if(typeof t[0]=="string"){const[o,n,u]=t;switch(o){case U:return e[r]=new Date(n);case J:return e[r]=new URL(n);case A:return e[r]=BigInt(n);case V:return e[r]=new RegExp(n,u);case G:return e[r]=Symbol.for(n);case k:const f=new Set;e[r]=f;for(let c=1;c<t.length;c++)f.add(i.call(this,t[c]));return f;case B:const h=new Map;e[r]=h;for(let c=1;c<t.length;c+=2)h.set(i.call(this,t[c]),i.call(this,t[c+1]));return h;case M:const w=Object.create(null);e[r]=w;for(const c in n)w[i.call(this,Number(c))]=i.call(this,n[c]);return w;case g:if(e[n])return e[r]=e[n];{const c=new S;return s[n]=c,e[r]=c.promise}case m:const[,T,v]=t;let I=v&&y&&y[v]?new y[v](T):new Error(T);return e[r]=I,I;case F:return i.call(this,n);default:if(Array.isArray(l)){const c=t.slice(1).map(E=>i.call(this,E));for(const E of l){const N=E(t[0],...c);if(N)return e[r]=N.value}}throw new SyntaxError}}else{const o=[];e[r]=o;for(let n=0;n<t.length;n++){const u=t[n];u!==P&&(o[n]=i.call(this,u))}return o}else{const o={};e[r]=o;for(const n in t)o[i.call(this,Number(n))]=i.call(this,t[n]);return o}}async function H(r,e){const{plugins:a}=e??{},s=new S,l=r.pipeThrough(q()).getReader(),t={values:[],hydrated:[],deferred:{},plugins:a},o=await Z.call(t,l);let n=s.promise;return o.done?s.resolve():n=$.call(t,l).then(s.resolve).catch(u=>{for(const f of Object.values(t.deferred))f.reject(u);s.reject(u)}),{done:n.then(()=>l.closed),value:o.value}}async function Z(r){const e=await r.read();if(!e.value)throw new SyntaxError;let a;try{a=JSON.parse(e.value)}catch{throw new SyntaxError}return{done:e.done,value:p.call(this,a)}}async function $(r){let e=await r.read();for(;!e.done;){if(!e.value)continue;const a=e.value;switch(a[0]){case g:{const s=a.indexOf(":"),l=Number(a.slice(1,s)),t=this.deferred[l];if(!t)throw new Error(`Deferred ID ${l} not found in stream`);const o=a.slice(s+1);let n;try{n=JSON.parse(o)}catch{throw new SyntaxError}const u=p.call(this,n);t.resolve(u);break}case m:{const s=a.indexOf(":"),l=Number(a.slice(1,s)),t=this.deferred[l];if(!t)throw new Error(`Deferred ID ${l} not found in stream`);const o=a.slice(s+1);let n;try{n=JSON.parse(o)}catch{throw new SyntaxError}const u=p.call(this,n);t.reject(u);break}default:throw new SyntaxError}e=await r.read()}}export{H as d};
